# Nuke Testing Patterns - Research Report

---

**Date**: 2025-12-26  
**Researcher**: AI Strategic Agent  
**Status**: Complete

## Executive Summary

Nuke Build enables **build-as-code testing** through standard .NET testing frameworks (xUnit, NUnit, MSTest). The build system itself is testable because it's regular C# codeâ€”targets can be unit tested, integration tested, and validated for cross-platform compatibility. Nuke provides **fail-fast patterns**, **isolated target execution**, and **cross-platform CI/CD integration** that ensures consistent behavior across Windows, Linux, and macOS.

**Key Finding**: Treating builds as first-class code means **build scripts can and should be tested** like any other application code.

---

## Testing the Build System

### Unit Testing Build Targets

**Approach**: Test target logic in isolation

**Example**:
```csharp
// Build.cs
public class Build : NukeBuild
{
    public IEnumerable<Project> GetTestProjects()
    {
        return Solution.GetProjects("*.Tests");
    }
    
    Target Test => _ => _
        .Executes(() =>
        {
            var testProjects = GetTestProjects();
            foreach (var project in testProjects)
                DotNetTest(s => s.SetProjectFile(project));
        });
}

// Build.Tests/BuildTests.cs
public class BuildTests
{
    [Fact]
    public void GetTestProjects_ReturnsOnlyTestProjects()
    {
        var build = new Build();
        var testProjects = build.GetTestProjects();
        
        Assert.All(testProjects, p => 
            Assert.EndsWith(".Tests", p.Name));
    }
}
```

**Benefits**:
- Validate build logic without executing
- Fast feedback (no actual builds)
- Regression prevention
- Refactoring confidence

### Integration Testing Build Targets

**Approach**: Execute actual build in test environment

**Example**:
```csharp
public class BuildIntegrationTests
{
    [Fact]
    public async Task Clean_RemovesArtifactsDirectory()
    {
        // Arrange
        var tempDir = Path.GetTempPath() / "test-build";
        var artifactsDir = tempDir / "artifacts";
        Directory.CreateDirectory(artifactsDir);
        
        // Act
        var result = await ExecuteBuildAsync(tempDir, targets: "Clean");
        
        // Assert
        Assert.True(result.ExitCode == 0);
        Assert.False(Directory.Exists(artifactsDir));
    }
}
```

**Challenges**:
- Slower (actual compilation)
- Environment setup complexity
- Test isolation (shared state)

**Solutions**:
- Use temporary directories
- Mock external dependencies
- Parallelize when possible

---

## Test Orchestration Patterns

### 1. Fail-Fast Pattern

**Principle**: Stop build immediately on first failure

**Implementation**:
```csharp
Target Test => _ => _
    .DependsOn(UnitTests, IntegrationTests)
    .Executes(() =>
    {
        Log.Information("All tests passed!");
    });

Target UnitTests => _ => _
    .Executes(() =>
    {
        DotNetTest(s => s
            .SetProjectFile(Solution)
            .SetFilter("Category=Unit")
            .EnableNoBuild());
        // Build stops here if tests fail
    });

Target IntegrationTests => _ => _
    .Executes(() =>
    {
        DotNetTest(s => s
            .SetProjectFile(Solution)
            .SetFilter("Category=Integration"));
    });
```

**Benefits**:
- Faster feedback (don't run all tests if early ones fail)
- Resource savings (CI minutes)
- Clear failure point

**Alternative: Continue-On-Error** (when needed):
```csharp
Target TestAllRegardless => _ => _
    .Executes(() =>
    {
        var failures = new List<string>();
        
        try
        {
            DotNetTest(s => s.SetFilter("Category=Unit"));
        }
        catch (Exception ex)
        {
            failures.Add("Unit tests failed");
        }
        
        try
        {
            DotNetTest(s => s.SetFilter("Category=Integration"));
        }
        catch (Exception ex)
        {
            failures.Add("Integration tests failed");
        }
        
        if (failures.Any())
            throw new Exception(string.Join(", ", failures));
    });
```

### 2. Parallel Test Execution

**Pattern**: Run independent test suites in parallel

**Implementation**:
```csharp
Target UnitTests => _ => _
    .Executes(() =>
    {
        DotNetTest(s => s.SetFilter("Category=Unit"));
    });

Target IntegrationTests => _ => _
    .Executes(() =>
    {
        DotNetTest(s => s.SetFilter("Category=Integration"));
    });

Target E2ETests => _ => _
    .Executes(() =>
    {
        DotNetTest(s => s.SetFilter("Category=E2E"));
    });

Target TestAll => _ => _
    .DependsOn(UnitTests, IntegrationTests, E2ETests)
    .Executes(() =>
    {
        Log.Information("All test suites completed!");
    });
```

**Execution**: UnitTests, IntegrationTests, E2ETests run **in parallel** (if CI supports)

**Benefits**:
- Faster total execution time
- Better CI resource utilization
- Clear separation of test types

### 3. Conditional Test Execution

**Pattern**: Run expensive tests only when needed

**Implementation**:
```csharp
Target E2ETests => _ => _
    .OnlyWhenStatic(() => IsServerBuild || HasE2EChanges())
    .Executes(() =>
    {
        PlaywrightTest(s => s.SetFilter("Category=E2E"));
    });

bool HasE2EChanges()
{
    var changedFiles = GitTasks.Git("diff --name-only HEAD~1");
    return changedFiles.Any(f => f.StartsWith("tests/E2E/"));
}
```

**Benefits**:
- Skip expensive tests locally (run only in CI)
- Smart test selection (only affected tests)
- Faster developer feedback

---

## Cross-Platform Testing

### Platform-Specific Targets

```csharp
Target TestWindows => _ => _
    .OnlyWhenStatic(() => IsWin)
    .Executes(() =>
    {
        DotNetTest(s => s
            .SetFilter("Category=Windows")
            .SetConfiguration(Configuration));
    });

Target TestLinux => _ => _
    .OnlyWhenStatic(() => IsUnix && !IsOsx)
    .Executes(() =>
    {
        DotNetTest(s => s
            .SetFilter("Category=Linux"));
    });

Target TestMacOS => _ => _
    .OnlyWhenStatic(() => IsOsx)
    .Executes(() =>
    {
        DotNetTest(s => s
            .SetFilter("Category=MacOS"));
    });

Target TestAll => _ => _
    .DependsOn(TestWindows, TestLinux, TestMacOS)
    .Executes(() => { /* Aggregate */ });
```

### Multi-Platform CI Matrix

**GitHub Actions Integration**:
```csharp
[GitHubActions(
    "continuous",
    GitHubActionsImage.WindowsLatest,
    GitHubActionsImage.UbuntuLatest,
    GitHubActionsImage.MacOsLatest,
    InvokedTargets = new[] { nameof(Test) })]
public class Build : NukeBuild
{
    Target Test => _ => _
        .Executes(() =>
        {
            DotNetTest(s => s
                .SetProjectFile(Solution)
                .SetConfiguration(Configuration));
        });
}
```

**Generated YAML**:
```yaml
name: continuous

on:
  push:
    branches: [main]

jobs:
  test:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Run Build
        run: ./build.sh Test
```

**Benefits**:
- Single source of truth (C# code)
- Auto-generated CI configuration
- Compiler-verified CI definitions
- Easy to add/remove platforms

---

## Test Result Reporting

### Aggregation Pattern

```csharp
Target Test => _ => _
    .Executes(() =>
    {
        var testResults = new List<TestResult>();
        
        var testProjects = Solution.GetProjects("*.Tests");
        foreach (var project in testProjects)
        {
            var result = DotNetTest(s => s
                .SetProjectFile(project)
                .SetResultsDirectory(ArtifactsDirectory / "test-results")
                .SetLoggers("trx"));
            
            testResults.Add(ParseTestResult(result));
        }
        
        GenerateTestReport(testResults);
    });

void GenerateTestReport(List<TestResult> results)
{
    var summary = new StringBuilder();
    summary.AppendLine("Test Summary:");
    summary.AppendLine($"Total: {results.Sum(r => r.Total)}");
    summary.AppendLine($"Passed: {results.Sum(r => r.Passed)}");
    summary.AppendLine($"Failed: {results.Sum(r => r.Failed)}");
    summary.AppendLine($"Skipped: {results.Sum(r => r.Skipped)}");
    
    Log.Information(summary.ToString());
    
    if (results.Any(r => r.Failed > 0))
        throw new Exception($"{results.Sum(r => r.Failed)} tests failed!");
}
```

### Coverage Reporting

```csharp
Target Coverage => _ => _
    .DependsOn(Test)
    .Executes(() =>
    {
        DotNetTest(s => s
            .SetProjectFile(Solution)
            .SetConfiguration(Configuration)
            .EnableCollectCoverage()
            .SetCoverletOutputFormat(CoverletOutputFormat.cobertura)
            .SetResultsDirectory(ArtifactsDirectory / "coverage"));
        
        ReportGenerator(s => s
            .SetReports(ArtifactsDirectory / "coverage" / "*.cobertura.xml")
            .SetTargetDirectory(ArtifactsDirectory / "coverage-report")
            .SetReportTypes(ReportTypes.Html, ReportTypes.Badges));
    });
```

**Output**:
- Cobertura XML for CI integration
- HTML report for browsing
- Badges for README

---

## Architecture Validation Testing

### NetArchTest Integration

**Pattern**: Validate architectural rules as tests

**Example**:
```csharp
public class ArchitectureTests
{
    [Fact]
    public void Controllers_ShouldNotDependOnInfrastructure()
    {
        var result = Types.InAssembly(typeof(MyController).Assembly)
            .That().ResideInNamespace("MyApp.Controllers")
            .ShouldNot().HaveDependencyOn("MyApp.Infrastructure")
            .GetResult();
        
        Assert.True(result.IsSuccessful);
    }
    
    [Fact]
    public void Entities_ShouldBeSealed()
    {
        var result = Types.InAssembly(typeof(Entity).Assembly)
            .That().ResideInNamespace("MyApp.Domain.Entities")
            .Should().BeSealed()
            .GetResult();
        
        Assert.True(result.IsSuccessful);
    }
}
```

**Benefits**:
- Enforce architectural boundaries
- Prevent dependency violations
- Self-documenting architecture rules
- CI-verified architecture

---

## Applicability to .xeyth Framework

### High-Value Patterns

1. **Fail-Fast Test Execution**
   - Fast feedback on failures
   - Resource-efficient
   - Clear failure reporting

2. **Parallel Test Orchestration**
   - Independent test suites run concurrently
   - Faster CI builds
   - Better resource utilization

3. **Cross-Platform Testing**
   - Validate on all supported platforms
   - Matrix-based CI configuration
   - Platform-specific test filtering

4. **Architecture Validation**
   - Enforce framework conventions
   - Prevent architectural drift
   - Self-documenting rules

### Integration Opportunities

#### High Priority

1. **Implement Fail-Fast Pattern**
   - **Where**: Build.cs Test target
   - **Why**: Faster feedback, resource savings
   - **Effort**: Small (already default behavior)
   - **Impact**: Medium (better CI efficiency)

2. **Add Architecture Tests**
   - **Where**: Automation.Framework.Tests
   - **Why**: Enforce conventions, prevent violations
   - **Effort**: Medium (add NetArchTest, write rules)
   - **Impact**: High (maintain architecture quality)

3. **Cross-Platform CI Matrix**
   - **Where**: GitHub Actions workflow
   - **Why**: Validate on Windows, Linux, macOS
   - **Effort**: Medium (configure matrix)
   - **Impact**: High (platform compatibility assurance)

#### Medium Priority

4. **Test Result Aggregation**
   - **Where**: Build.cs Test target
   - **Why**: Clear summary, better reporting
   - **Effort**: Medium (parse results, generate report)
   - **Impact**: Medium (improved visibility)

5. **Conditional Test Execution**
   - **Where**: E2E tests (Playwright)
   - **Why**: Skip expensive tests locally
   - **Effort**: Small (add conditions)
   - **Impact**: Medium (faster local builds)

---

## Specific Integration Recommendations

### Recommendation 1: Architecture Validation Suite

**Proposal**: Add NetArchTest-based architecture tests

**Implementation**:
```csharp
public class FrameworkArchitectureTests
{
    [Fact]
    public void Framework_ShouldNotDependOnApplicationCode()
    {
        var result = Types.InAssembly(typeof(AiFramework).Assembly)
            .That().ResideInNamespace("Automation.Framework")
            .ShouldNot().HaveDependencyOn("Automation.Verify")
            .And().ShouldNot().HaveDependencyOn("Contracts.Cli")
            .GetResult();
        
        Assert.True(result.IsSuccessful);
    }
    
    [Fact]
    public void Prompts_ShouldHaveMarkdownExtension()
    {
        var promptFiles = Directory.GetFiles("Ai/Framework", "*.prompt.*");
        
        Assert.All(promptFiles, file =>
            Assert.EndsWith(".md", file));
    }
    
    [Fact]
    public void Tasks_ShouldFollowNamingConvention()
    {
        var taskFiles = Directory.GetFiles(".", "*.task", SearchOption.AllDirectories);
        
        Assert.All(taskFiles, file =>
        {
            var fileName = Path.GetFileName(file);
            Assert.Matches(@"^[A-Z][a-zA-Z]+\.task$", fileName);
        });
    }
}
```

### Recommendation 2: Cross-Platform Test Matrix

**Proposal**: Test framework on all supported platforms

**Build Integration**:
```csharp
[GitHubActions(
    "ci",
    GitHubActionsImage.WindowsLatest,
    GitHubActionsImage.UbuntuLatest,
    GitHubActionsImage.MacOsLatest,
    OnPushBranches = new[] { "main", "develop" },
    OnPullRequestBranches = new[] { "main", "develop" },
    InvokedTargets = new[] { nameof(Test) })]
public class Build : NukeBuild
{
    Target Test => _ => _
        .DependsOn(Compile)
        .Executes(() =>
        {
            DotNetTest(s => s
                .SetProjectFile(Solution)
                .SetConfiguration(Configuration)
                .EnableNoBuild());
        });
}
```

### Recommendation 3: Test Orchestration with Reporting

**Proposal**: Aggregate test results and generate summary

**Implementation**:
```csharp
Target Test => _ => _
    .DependsOn(Compile)
    .Executes(() =>
    {
        var testProjects = Solution.GetProjects("*.Tests");
        var results = new List<TestResult>();
        
        foreach (var project in testProjects)
        {
            Log.Information($"Testing {project.Name}...");
            
            DotNetTest(s => s
                .SetProjectFile(project)
                .SetConfiguration(Configuration)
                .SetResultsDirectory(ArtifactsDirectory / "test-results")
                .SetLoggers($"trx;LogFileName={project.Name}.trx")
                .EnableNoBuild());
        }
        
        GenerateTestSummary();
    });

void GenerateTestSummary()
{
    var trxFiles = GlobFiles(ArtifactsDirectory / "test-results", "*.trx");
    var summary = ParseTrxFiles(trxFiles);
    
    Log.Information("Test Summary:");
    Log.Information($"  Total: {summary.Total}");
    Log.Information($"  Passed: {summary.Passed}");
    Log.Information($"  Failed: {summary.Failed}");
    Log.Information($"  Skipped: {summary.Skipped}");
    
    if (summary.Failed > 0)
        throw new Exception($"{summary.Failed} tests failed!");
}
```

---

## Anti-Patterns to Avoid

### 1. No Build System Tests

**Problem**: Build logic untested, breaks unexpectedly

**Nuke's Approach**: Test build code like app code

**Lesson**: Validate build logic, not just application code

### 2. Sequential Test Execution Only

**Problem**: Slow feedback, wasted CI time

**Nuke's Approach**: Parallel execution for independent targets

**Lesson**: Leverage parallelism for faster builds

### 3. Platform-Specific Assumptions

**Problem**: Works on Windows, breaks on Linux/macOS

**Nuke's Approach**: Multi-platform CI matrix

**Lesson**: Test on all supported platforms

### 4. Ignoring Architecture Drift

**Problem**: Codebase violates architectural principles over time

**Nuke's Pattern**: NetArchTest for automated validation

**Lesson**: Make architecture rules testable and CI-verified

---

## Conclusion

Nuke Build's testing approach demonstrates that **build systems can and should be tested** using the same rigor as application code. The combination of fail-fast execution, parallel orchestration, cross-platform validation, and architecture tests creates a robust, maintainable build system.

**Primary Takeaway**: **Build-as-code = testable builds = reliable automation**.

**Recommended Next Steps**:
1. Add architecture validation tests
2. Configure cross-platform CI matrix
3. Implement test result aggregation
4. Add conditional test execution for expensive tests

**Risk Assessment**: Low - Standard testing practices, well-established tools.

---

## References

- Build Execution: https://nuke.build/docs/getting-started/execution/
- CI/CD Integration: https://nuke.build/docs/cicd/
- Fail-Fast Pattern: https://company.plarium.com/en/articles/ci-cd-the-fail-fast-approach-in-nuke/
- NetArchTest: https://github.com/BenMorris/NetArchTest
- Cross-Platform Build: https://dev.to/damikun/the-cross-platform-build-automation-with-nuke-1kmc
