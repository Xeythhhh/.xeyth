# Nuke Package Management - Research Report

---

**Date**: 2025-12-26  
**Researcher**: AI Strategic Agent  
**Status**: Complete

## Executive Summary

Nuke Build provides **opinionated NuGet package management** through CLI commands (`:add-package`), supports multiple **versioning strategies** (GitVersion, MinVer, Nerdbank.GitVersioning), and leverages **.NET's Central Package Management** (CPM) for version consistency. The system distinguishes between `PackageReference` (dependencies) and `PackageDownload` (tools), enabling clean dependency graphs while supporting tool acquisition.

**Key Finding**: Nuke demonstrates that **package management can be simple and convention-driven** without sacrificing flexibility or control.

---

## Package Addition and Management

### CLI-Based Package Management

**Command**: `nuke :add-package <package-id> [--version <version>]`

**Examples**:
```bash
nuke :add-package Newtonsoft.Json                    # Latest version
nuke :add-package Serilog --version 3.1.1            # Specific version
nuke :add-package Nuke.Common                        # Framework package
```

**Behavior**:
- Auto-detects package type (library vs tool)
- Uses `PackageReference` for libraries
- Uses `PackageDownload` for tools (no dependency propagation)
- Updates build project (.csproj)
- Restores packages automatically

### PackageReference vs PackageDownload

**PackageReference** (Dependencies):
```xml
<ItemGroup>
  <PackageReference Include="Serilog" Version="3.1.1" />
  <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
</ItemGroup>
```

**Characteristics**:
- Included in dependency graph
- Transitive dependencies resolved
- Affects runtime/compilation
- Used for libraries, frameworks

**PackageDownload** (Tools):
```xml
<ItemGroup>
  <PackageDownload Include="GitVersion.Tool" Version="[5.12.0]" />
  <PackageDownload Include="ReportGenerator" Version="[5.1.0]" />
</ItemGroup>
```

**Characteristics**:
- Downloaded but not referenced
- No dependency propagation
- Used for CLI tools, analyzers
- Cleaner dependency graph

**Benefits**:
- Separation of concerns (tools vs libraries)
- Reduced dependency bloat
- Explicit tool versioning
- Faster restoration (no transitive resolution for tools)

---

## Versioning Strategies

Nuke supports **attribute-based versioning** with multiple providers:

### 1. GitVersion

**Setup**:
```csharp
[GitVersion] readonly GitVersion GitVersion;

Target Pack => _ => _
    .Executes(() =>
    {
        DotNetPack(s => s
            .SetVersion(GitVersion.NuGetVersionV2)
            .SetAssemblyVersion(GitVersion.AssemblySemVer)
            .SetFileVersion(GitVersion.AssemblySemFileVer));
    });
```

**Features**:
- Git-based semantic versioning
- Branch-specific version strategies (main: 1.0.0, develop: 1.0.0-beta.1)
- Tag-based releases
- Commit-based pre-release versions

**Properties**:
- `GitVersion.MajorMinorPatch` → `1.2.3`
- `GitVersion.NuGetVersionV2` → `1.2.3-beta.1`
- `GitVersion.SemVer` → `1.2.3-beta.1+42`
- `GitVersion.FullSemVer` → `1.2.3-beta.1+Branch.develop.Sha.abc123`

### 2. MinVer

**Setup**:
```csharp
[MinVer] readonly MinVer MinVer;

Target Pack => _ => _
    .Executes(() =>
    {
        DotNetPack(s => s.SetVersion(MinVer.Version));
    });
```

**Features**:
- Minimal configuration (convention-based)
- Tag-based versioning (reads Git tags)
- Height-based pre-release versions
- No config files required

**Properties**:
- `MinVer.Version` → `1.2.3-alpha.0.4`
- `MinVer.Major`, `MinVer.Minor`, `MinVer.Patch`

### 3. Nerdbank.GitVersioning

**Setup**:
```csharp
[NerdbankGitVersioning] readonly NerdbankGitVersioning Versioning;

Target Pack => _ => _
    .Executes(() =>
    {
        DotNetPack(s => s.SetVersion(Versioning.NuGetPackageVersion));
    });
```

**Features**:
- `version.json` configuration
- Deterministic builds (same commit = same version)
- Public release detection
- Commit height in version

**Properties**:
- `Versioning.SimpleVersion` → `1.2.3`
- `Versioning.NuGetPackageVersion` → `1.2.3-beta+42`
- `Versioning.SemVer2` → `1.2.3-beta.42`

### Comparison Matrix

| Feature | GitVersion | MinVer | Nerdbank.GitVersioning |
|---------|-----------|--------|------------------------|
| **Config Complexity** | High (gitversion.yml) | Low (tags only) | Medium (version.json) |
| **Branch Strategies** | ✅ Extensive | ⚠️ Basic | ✅ Configurable |
| **Deterministic** | ⚠️ Depends on config | ✅ Yes | ✅ Yes |
| **Pre-release Support** | ✅ Extensive | ✅ Basic | ✅ Good |
| **Metadata Support** | ✅ Full SemVer 2.0 | ✅ Basic | ✅ Full SemVer 2.0 |
| **Learning Curve** | High | Low | Medium |

**Recommendation**: 
- **MinVer**: Simple projects, tag-based releases
- **GitVersion**: Complex branching strategies (GitFlow)
- **Nerdbank**: Deterministic builds, monorepos

---

## Dependency Resolution

### NuGet Resolution Process

**Steps**:
1. Parse project files and build dependency graph
2. Resolve package versions based on constraints
3. Apply conflict resolution (direct dependencies win)
4. Download packages to global cache (`~/.nuget/packages`)
5. Create `project.assets.json` with resolved versions

**Resolution Rules**:
- **Lowest Applicable Version**: Selects minimum version satisfying all constraints
- **Direct Wins**: Direct dependencies override transitive dependencies
- **Floating Versions**: `1.2.*` resolves to latest matching patch
- **Version Ranges**: `[1.0.0, 2.0.0)` includes 1.x, excludes 2.0.0

### Central Package Management (CPM)

**File**: `Directory.Packages.props` (solution root)

**Structure**:
```xml
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- Package versions defined centrally -->
    <PackageVersion Include="Serilog" Version="3.1.1" />
    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageVersion Include="Spectre.Console" Version="0.50.0" />
  </ItemGroup>
</Project>
```

**Project Files** (no versions):
```xml
<ItemGroup>
  <PackageReference Include="Serilog" />
  <PackageReference Include="Newtonsoft.Json" />
</ItemGroup>
```

**Benefits**:
- Single source of truth for versions
- Easy version updates (change once, affect all projects)
- Prevent version drift across projects
- Simpler project files

**Overrides** (when needed):
```xml
<!-- Allow specific project to override -->
<ItemGroup>
  <PackageReference Include="Serilog" VersionOverride="3.2.0" />
</ItemGroup>
```

### Dependency Conflict Resolution

**Scenario**: Project A needs Pkg v1.0, Project B needs Pkg v2.0

**Resolution**:
1. If one is direct dependency, it wins
2. If both direct, highest version wins (with warning)
3. If both transitive, lowest common version
4. Manual override via `Directory.Packages.props`

**Example**:
```xml
<!-- Force specific version across solution -->
<ItemGroup>
  <PackageVersion Include="Problematic.Package" Version="2.0.0" />
</ItemGroup>
```

---

## NuGet Package Creation

### Package Target

```csharp
Target Pack => _ => _
    .DependsOn(Compile)
    .Executes(() =>
    {
        DotNetPack(s => s
            .SetProject(Solution)
            .SetConfiguration(Configuration)
            .SetVersion(GitVersion.NuGetVersionV2)
            .SetOutputDirectory(ArtifactsDirectory)
            .EnableNoBuild());
    });
```

**Output**: `.nupkg` files in `ArtifactsDirectory`

### Package Metadata

**Source**: Project file or `Directory.Build.props`

```xml
<PropertyGroup>
  <PackageId>Xeyth.Automation.Framework</PackageId>
  <Title>Xeyth Automation Framework</Title>
  <Description>AI-driven automation framework for .NET</Description>
  <Authors>Xeyth</Authors>
  <PackageTags>ai;automation;framework</PackageTags>
  <PackageLicenseExpression>MIT</PackageLicenseExpression>
  <PackageProjectUrl>https://github.com/Xeythhhh/.xeyth</PackageProjectUrl>
  <RepositoryUrl>https://github.com/Xeythhhh/.xeyth</RepositoryUrl>
  <RepositoryType>git</RepositoryType>
  <PackageReadmeFile>README.md</PackageReadmeFile>
  <PackageIcon>icon.png</PackageIcon>
</PropertyGroup>

<ItemGroup>
  <None Include="README.md" Pack="true" PackagePath="\" />
  <None Include="icon.png" Pack="true" PackagePath="\" />
</ItemGroup>
```

### Multi-Targeting

```xml
<PropertyGroup>
  <TargetFrameworks>net6.0;net7.0;net8.0;net10.0</TargetFrameworks>
</PropertyGroup>
```

**Package Structure**:
```
Xeyth.Automation.Framework.1.0.0.nupkg
├── lib/
│   ├── net6.0/
│   │   └── Xeyth.Automation.Framework.dll
│   ├── net7.0/
│   │   └── Xeyth.Automation.Framework.dll
│   ├── net8.0/
│   │   └── Xeyth.Automation.Framework.dll
│   └── net10.0/
│       └── Xeyth.Automation.Framework.dll
├── Xeyth.Automation.Framework.nuspec
└── README.md
```

---

## Package Publishing

### Publishing Workflow

```csharp
Target Publish => _ => _
    .DependsOn(Pack)
    .Requires(() => NuGetApiKey)
    .Executes(() =>
    {
        var packages = GlobFiles(ArtifactsDirectory, "*.nupkg");
        
        DotNetNuGetPush(s => s
            .SetSource("https://api.nuget.org/v3/index.json")
            .SetApiKey(NuGetApiKey)
            .CombineWith(packages, (ss, package) => ss
                .SetTargetPath(package)));
    });
```

**Features**:
- Secret-based API key (`.Requires(() => NuGetApiKey)`)
- Batch publishing (`.CombineWith()`)
- Target source (NuGet.org, GitHub Packages, Azure Artifacts)

### GitHub Packages Integration

```csharp
Target PublishToGitHub => _ => _
    .DependsOn(Pack)
    .Requires(() => GitHubToken)
    .Executes(() =>
    {
        DotNetNuGetPush(s => s
            .SetSource($"https://nuget.pkg.github.com/{Repository.GetGitHubOwner()}/index.json")
            .SetApiKey(GitHubToken)
            .SetTargetPath(ArtifactsDirectory / "*.nupkg"));
    });
```

**Setup**:
1. Generate GitHub personal access token (write:packages)
2. Store as secret: `nuke :secrets set GitHubToken`
3. Run: `nuke PublishToGitHub`

---

## Applicability to .xeyth Framework

### High-Value Patterns

1. **Central Package Management**
   - Single version source
   - Consistent dependencies
   - Easy updates

2. **Automated Versioning**
   - Git-based versions
   - No manual version bumps
   - Branch-specific strategies

3. **PackageReference vs PackageDownload**
   - Cleaner dependency graphs
   - Explicit tool management
   - Faster restoration

4. **Publish Automation**
   - One-command publishing
   - Secret management
   - Multi-target support

### Integration Opportunities

#### High Priority

1. **Adopt Central Package Management**
   - **Where**: Entire solution
   - **Why**: Version consistency, easier updates
   - **Effort**: Small (create `Directory.Packages.props`, migrate)
   - **Impact**: High (maintainability improvement)

2. **Implement GitVersion or MinVer**
   - **Where**: All projects
   - **Why**: Automated semantic versioning
   - **Effort**: Medium (choose strategy, configure)
   - **Impact**: High (no manual version management)

3. **Distinguish PackageDownload for Tools**
   - **Where**: Build project
   - **Why**: Cleaner dependency graph
   - **Effort**: Small (change ItemGroup type)
   - **Impact**: Medium (cleaner builds)

#### Medium Priority

4. **Automated Package Publishing**
   - **Where**: CI/CD pipelines
   - **Why**: Streamlined releases
   - **Effort**: Medium (CI integration)
   - **Impact**: Medium (faster releases)

5. **Multi-Targeting Strategy**
   - **Where**: Framework libraries
   - **Why**: Broader compatibility
   - **Effort**: Small (add TargetFrameworks)
   - **Impact**: Low (if not needed yet)

---

## Specific Integration Recommendations

### Recommendation 1: Central Package Management Setup

**Proposal**: Create `Directory.Packages.props` for version unification

**Implementation**:

**File**: `Directory.Packages.props`
```xml
<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- Automation Framework -->
    <PackageVersion Include="Spectre.Console" Version="0.50.0" />
    <PackageVersion Include="Serilog" Version="4.1.0" />
    <PackageVersion Include="Serilog.Sinks.Console" Version="6.0.0" />
    <PackageVersion Include="Serilog.Sinks.File" Version="6.0.0" />
    
    <!-- Testing -->
    <PackageVersion Include="xunit" Version="2.9.0" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="2.8.2" />
    <PackageVersion Include="Verify.Xunit" Version="28.4.0" />
    <PackageVersion Include="FluentAssertions" Version="7.0.0" />
    
    <!-- Code Analysis -->
    <PackageVersion Include="Microsoft.CodeAnalysis.NetAnalyzers" Version="9.0.0" />
  </ItemGroup>
</Project>
```

**Benefits**:
- Single version update affects all projects
- Prevents version drift
- Easier dependency audits
- Simpler project files

### Recommendation 2: GitVersion Integration

**Proposal**: Add GitVersion for semantic versioning

**Setup**:

**File**: `gitversion.yml`
```yaml
mode: Mainline
branches:
  main:
    tag: ''
  develop:
    tag: beta
    increment: Minor
  feature:
    tag: alpha
    increment: Patch
```

**Build Integration**:
```csharp
[GitVersion] readonly GitVersion GitVersion;

Target Pack => _ => _
    .Executes(() =>
    {
        DotNetPack(s => s
            .SetVersion(GitVersion.NuGetVersionV2)
            .SetProperty("PackageReleaseNotes", GetReleaseNotes()));
    });
```

**Versioning Strategy**:
- `main` branch: `1.0.0`, `1.1.0`, `1.2.0`
- `develop` branch: `1.1.0-beta.1`, `1.1.0-beta.2`
- `feature/*`: `1.0.1-alpha.1`, `1.0.1-alpha.2`
- Tags: `v1.0.0` creates release version

### Recommendation 3: Tool Package Separation

**Proposal**: Use PackageDownload for build tools

**Current** (implicit dependencies):
```xml
<ItemGroup>
  <PackageReference Include="GitVersion.Tool" Version="5.12.0" />
  <PackageReference Include="ReportGenerator" Version="5.1.0" />
</ItemGroup>
```

**Recommended** (explicit tools):
```xml
<ItemGroup>
  <PackageDownload Include="GitVersion.Tool" Version="[5.12.0]" />
  <PackageDownload Include="ReportGenerator" Version="[5.1.0]" />
</ItemGroup>
```

**Benefits**:
- Tools don't pollute dependency graph
- Explicit version locking (`[version]` syntax)
- Faster restoration

---

## Anti-Patterns to Avoid

### 1. Version Duplication

**Problem**: Same package version specified in multiple projects

**Nuke's Solution**: Central Package Management

**Lesson**: Define versions once, reference everywhere

### 2. Manual Version Bumping

**Problem**: Forgetting to update version before release

**Nuke's Solution**: Automated versioning (GitVersion/MinVer)

**Lesson**: Let Git commits/tags drive versioning

### 3. Tool Dependencies in Main Graph

**Problem**: Build tools included as regular package references

**Nuke's Solution**: PackageDownload for tools

**Lesson**: Separate tools from runtime dependencies

### 4. Hardcoded Package Sources

**Problem**: Package source URLs in code

**Nuke's Solution**: Parameter-based sources

**Lesson**: Make sources configurable

---

## Conclusion

Nuke Build's package management approach demonstrates that **NuGet can be simple and automated** through Central Package Management, automated versioning, and thoughtful dependency separation. The distinction between dependencies and tools, combined with Git-based versioning, eliminates manual version management overhead.

**Primary Takeaway**: **Centralize versions + automate versioning = maintainable dependency management**.

**Recommended Next Steps**:
1. Create `Directory.Packages.props` for .xeyth solution
2. Choose and configure versioning strategy (recommend GitVersion)
3. Migrate build tools to PackageDownload
4. Automate package publishing in CI

**Risk Assessment**: Low - CPM and GitVersion are mature, widely-adopted solutions.

---

## References

- Adding Packages: https://nuke.build/docs/global-tool/packages/
- Versioning: https://nuke.build/docs/common/versioning/
- Central Package Management: https://learn.microsoft.com/en-us/nuget/consume-packages/central-package-management
- NuGet Dependency Resolution: https://learn.microsoft.com/en-us/nuget/concepts/dependency-resolution
- GitVersion: https://gitversion.net/
- MinVer: https://github.com/adamralph/minver
