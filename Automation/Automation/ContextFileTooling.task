# Context File Tooling - Dotnet CLI Utilities

**Status**: Ready for Implementation  
**Created**: 2024-12-24  
**Owner**: Strategic Agent (Planner)  
**Priority**: Medium  
**Effort**: Large  
**Priority Score**: 6 (Impact:4 + Urgency:2 + Dependency:3 - Complexity:3 - Enables automation)

---

## DELEGATION PROMPT

````markdown
**Task**: [Automation/ContextFileTooling.task](Automation/ContextFileTooling.task)  
**Role**: Planner (see [../Framework/Strategic.prompt.md](../Framework/Strategic.prompt.md))  
**Target Audience**: Strategic Agent (Claude Sonnet 4.5)

Design and plan dotnet CLI tooling utilities for querying/managing AI framework context files (.task, .plan, .report, etc.) for use in automations, pipelines, and other projects.
````

---

## Context

AI framework uses structured context files (.task, .plan, .report, .convention, .template, .inventory) across vertical slices. Currently no programmatic query/management tooling exists for:
- Discovering all plans/tasks
- Finding artifacts for specific tasks
- Filtering completed vs pending work
- Extracting metadata (status, owner, dates)
- Automation integration

Need simple dotnet CLI tools that can be invoked from scripts, pipelines, or other .NET projects.

## Objective

Design and implement dotnet CLI tooling suite for context file management:
- **Discovery**: Find all plans, tasks, reports, conventions
- **Querying**: Filter by status, slice, type, date
- **Relationships**: Map tasks to plans, artifacts to tasks
- **Metadata Extraction**: Parse structured fields (status, owner, dates)
- **Automation-Friendly**: JSON output, exit codes, pipeline integration

## Deliverables

1. **Architecture Design**: Tool structure, technology choices (dotnet tool vs library)
2. **Utility Specifications**: Each tool's purpose, inputs, outputs, examples
3. **Implementation Plan**: Phased approach, dependencies, testing strategy
4. **Integration Examples**: How to use in automations/pipelines

## Success Criteria

- [ ] CLI tools discoverable and runnable via dotnet CLI
- [ ] JSON output for automation consumption
- [ ] Cross-platform (Windows, macOS, Linux)
- [ ] All core context file types supported (.task, .plan, .report, .convention, .template, .inventory)
- [ ] Can be consumed by other projects in solution
- [ ] Documentation with usage examples

## Proposed Utilities (Initial List)

**Discovery**:
- `GetAllPlans` - List all .plan files
- `GetAllTasks` - List all .task files
- `GetAllReports` - List all .report files
- `GetAllConventions` - List all .convention files

**Filtering**:
- `GetTasksForPlan` - Tasks related to specific plan
- `GetArtifactsForTask` - Reports/outputs for specific task
- `GetCompletedTasks` - Tasks marked complete/archived
- `GetPendingTasks` - Tasks not started or in progress
- `GetTasksByStatus` - Filter by status field
- `GetTasksBySlice` - Filter by vertical slice

**Metadata**:
- `GetTaskMetadata` - Extract structured fields (status, owner, dates)
- `GetTaskProgress` - Parse progress log entries

**Automation**:
- `ValidateContextFile` - Check file follows conventions
- `ArchiveTask` - Move completed task to archive

## Architecture Decisions

### AD-1: Integration with Existing xeyth-planning Tool

**Decision**: Extend existing `Automation.Planning` CLI tool with context file commands  
**Rationale**:
- `Automation.Planning` already exists as CLI tool (`xeyth-planning`) for proposal management
- Adding context file commands alongside proposal commands creates comprehensive planning tool
- Reuses existing infrastructure (Spectre.Console, command dispatcher, reporter, Automation.Cli.Common)
- Avoids tool proliferation (single `xeyth-planning` tool for all planning/context operations)
- Library code within `Automation.Planning` can be consumed by other automation projects
- Pattern: Proposals use `.proposal` extension; context files use `.task`, `.plan`, `.report`, etc.

### AD-2: Technology Stack

**Decision**: 
- **Parser**: Regex-based markdown parsing for structured metadata extraction
- **Querying**: LINQ over discovered files with strongly-typed models
- **Output**: Spectre.Console for rich terminal output (already in use for proposals)
- **File System**: Directory.EnumerateFiles with SearchOption.AllDirectories (following existing pattern)
- **CLI Framework**: Custom command dispatcher (already implemented in Automation.Planning)
- **Dependencies**: Spectre.Console (already present), Automation.Cli.Common (shared utilities)

**Rationale**: Consistency with existing `xeyth-planning` proposal commands; proven patterns already working.

### AD-3: Project Structure

**Decision**: Extend existing `Automation.Planning` project structure:
```
src/
  Automation.Planning/         (Existing CLI tool - add new features)
    Models/                    (Add: ContextTask, ContextPlan, ContextReport, Convention)
                              (Existing: Proposal, ProposalStatus)
    Services/                  (Add: ContextFileDiscoveryService, ContextFileParser)
                              (Existing: ProposalDiscoveryService, ProposalParser, etc.)
    Commands/                  (Add: ListTasksCommand, GetTaskMetadataCommand, etc.)
                              (Existing: ListProposalsCommand, AcceptProposalCommand, etc.)
    Program.cs                 (Update: Register new commands in dispatcher)
    
  tests/
    Automation.Planning.Tests/ (Existing - add context file tests)
```

**Rationale**: Leverage existing infrastructure; avoid duplication; single cohesive planning tool.

### AD-4: Output Format

**Decision**: Spectre.Console table format (matching existing proposal commands), with optional JSON flag for automation  
**Default Table Output**:
```text
┌─────────────────────────┬──────────────┬────────────┬──────────────────┐
│ Name                    │ Status       │ Created    │ Owner            │
├─────────────────────────┼──────────────┼────────────┼──────────────────┤
│ MarkdownLintRemediation │ Not Started  │ 2024-12-24 │ Strategic Agent  │
└─────────────────────────┴──────────────┴────────────┴──────────────────┘
```
**JSON Output** (with `--json` flag for automation integration):
```json
[
  {
    "name": "MarkdownLintRemediation",
    "path": "Ai/Framework/MarkdownLintRemediation.task",
    "status": "Not Started",
    "owner": "Strategic Agent (Planner)",
    "created": "2024-12-24",
    "slice": "Ai/Framework"
  }
]
```

**Rationale**: Consistency with existing proposal commands (human-readable tables by default); optional JSON for CI/CD and scripting.

### AD-5: CLI Packaging and Usage

**Decision**: Extend existing `xeyth-planning` dotnet tool  
**Package Name**: `xeyth-planning` (no change)  
**Installation**: `dotnet tool install --global xeyth-planning` (existing)  
**Usage Examples**:
```bash
# Existing proposal commands (no change)
xeyth-planning list-proposals --pending
xeyth-planning accept-proposal MyProposal

# New context file commands
xeyth-planning list-tasks --root . --json
xeyth-planning list-tasks --status "Not Started"
xeyth-planning list-tasks --slice "Framework"
xeyth-planning list-plans --root .
xeyth-planning get-task-metadata MarkdownLintRemediation --json
xeyth-planning list-reports --task MarkdownLintRemediation
```

**Rationale**: Single tool for all planning operations; consistent interface; backward compatible with existing proposal commands.

### AD-6: Discovery Strategy

**Decision**: Convention-based file discovery with configurable root  
**Pattern**:
- Scan from specified root (default: current directory)
- Match patterns: `**/*.task`, `**/*.plan`, `**/*.report`, etc.
- Exclude `**/archive/**` by default (optional --include-archive flag)
- Parse frontmatter for structured metadata

**Rationale**: Flexible, mirrors framework conventions, performant with glob patterns.

### AD-7: Metadata Extraction

**Decision**: Parse structured sections via regex + convention  
**Extracted Fields**:
- Status: Extract from `**Status**: {value}` line
- Owner: Extract from `**Owner**: {value}` line
- Created: Extract from `**Created**: {value}` line
- Slice: Derive from file path
- Type: Derive from extension (.task, .plan, etc.)
- Progress Log: Parse ## Progress Log section

**Rationale**: Simple regex parsing sufficient for current format, extensible to YAML frontmatter later if needed.

## Verification

- All tools work cross-platform
- JSON output parseable by standard tools (jq, PowerShell ConvertFrom-Json)
- Integration tests with sample context files
- Documentation includes automation examples

## Implementation Plan

### Phase 1: Foundation (Implementation Agent)

**Add New Models** (in `Automation.Planning/Models/`):
- `ContextTask.cs` - Model for .task files (Name, Path, Status, Owner, Created, Priority, Effort, Content)
- `ContextPlan.cs` - Model for .plan files (Name, Path, Owner, Objective, Content)
- `ContextReport.cs` - Model for .report files (Name, Path, Date, Agent, Status, Content)
- `Convention.cs` - Model for .convention files (Name, Path, ApplyTo, Content)

**Add Parsing Services** (in `Automation.Planning/Services/`):
- `ContextFileParser.cs` - Base parser with regex-based metadata extraction
- `TaskParser.cs` - Parser for .task files (inherits ContextFileParser)
- `PlanParser.cs` - Parser for .plan files (inherits ContextFileParser)
- `ReportParser.cs` - Parser for .report files (inherits ContextFileParser)
- `ConventionParser.cs` - Parser for .convention files (inherits ContextFileParser)

**Add Discovery Services** (in `Automation.Planning/Services/`):
- `ContextFileDiscoveryService.cs` - Generic discovery service for context files (pattern: `*.{extension}`, excludes `**/archive/**`)

### Phase 2: Core Commands (Implementation Agent)

**Implement Discovery Commands** (in `Automation.Planning/Commands/`):
- `ListTasksCommand.cs` - List all .task files (options: `--root`, `--json`, `--include-archive`)
- `ListPlansCommand.cs` - List all .plan files (options: `--root`, `--json`)
- `ListReportsCommand.cs` - List all .report files (options: `--root`, `--json`, `--task <name>`)
- `ListConventionsCommand.cs` - List all .convention files (options: `--root`, `--json`)

**Command Base Pattern**:
- Inherit from `PlanningCommandBase` (existing base class)
- Follow existing pattern from `ListProposalsCommand`
- Use `StatusSpinner` for discovery operations
- Use `PlanningReporter` for output
- Support `--help` flag (inherited from base)

**Update Program.cs**:
- Register new commands in `CommandDispatcher`
- Add new commands to command array alongside existing proposal commands

### Phase 3: Filtering & Querying (Implementation Agent)

**Add Filtering to List Commands**:
- `ListTasksCommand` additional options:
  - `--status <status>` - Filter by exact status ("Not Started", "In Progress", "Completed")
  - `--slice <slice>` - Filter by vertical slice path (e.g., "Framework", "Git")
  - `--pending` - Shortcut for non-completed tasks
  - `--completed` - Shortcut for completed/archived tasks
  - `--owner <owner>` - Filter by owner field
  - `--since <date>` - Filter by created date (ISO format)

- `ListReportsCommand` additional options:
  - `--task <name>` - Filter reports related to specific task
  - `--agent <agent>` - Filter by agent (Strategic/Implementation)
  - `--since <date>` - Filter by report date

**Filtering Logic**:
- Implement in-memory LINQ filtering after discovery
- Case-insensitive matching for text filters
- Support partial matches for slice paths (e.g., "Frame" matches "Ai/Framework")

### Phase 4: Metadata & Relationships (Implementation Agent)

**Add Metadata Command** (in `Automation.Planning/Commands/`):
- `GetTaskMetadataCommand.cs` - Get detailed metadata for specific task
  - Usage: `xeyth-planning get-task-metadata <task-name> [--json] [--root .]`
  - Output: Full metadata (Status, Owner, Created, Priority, Effort, Objective, Deliverables, Progress Log)
  - Supports both table and JSON output

**Add Relationship Discovery**:
- `FindTaskReportsCommand.cs` - Find all reports for a specific task
  - Usage: `xeyth-planning find-task-reports <task-name> [--root .]`
  - Searches for `<TaskName>.task.*.report` pattern
  - Lists all related progress reports, blocker reports, review reports

- Update `ListReportsCommand` to show task relationships
  - Parse report filename to extract related task name
  - Display task association in output table

**Add Task-Plan Linking** (Future Enhancement - Phase 6):
- Parse "Related Task" field in plans
- Parse "Plan File" field in tasks
- Show bidirectional relationships

### Phase 5: Testing & Documentation (Implementation Agent)

**Unit Tests** (in `tests/Automation.Planning.Tests/`):
- `ContextFileParserTests.cs` - Test metadata extraction with sample markdown
- `TaskParserTests.cs` - Test .task file parsing (Status, Owner, Created, Priority, Effort)
- `PlanParserTests.cs` - Test .plan file parsing (Objective, Owner, Context)
- `ReportParserTests.cs` - Test .report file parsing (Date, Agent, Status)
- `ContextFileDiscoveryServiceTests.cs` - Test file discovery with mock file system
- `ListTasksCommandTests.cs` - Test command execution and filtering
- `GetTaskMetadataCommandTests.cs` - Test metadata extraction command

**Integration Tests**:
- End-to-end test with actual framework files (Ai/, Git/, Automation/)
- Verify discovery excludes `archive/` directories
- Verify JSON serialization round-trips correctly
- Test filtering with real data

**Documentation**:
- Update `README.md` in Automation.Planning with:
  - New context file command examples
  - Integration/automation examples (CI/CD, PowerShell scripts)
  - JSON output schema documentation
- Add XML doc comments to all public models and services
- Create `Automation.Planning.Commands.md` with command reference

### Phase 6: Advanced Features & Polish (Implementation Agent)

**JSON Output Support**:
- Add `--json` flag support to all list commands
- Serialize models using System.Text.Json
- Pretty-print JSON output (indented)
- Document JSON schema in README

**Helper Utilities** (Optional/Future):
- `ValidateTaskCommand.cs` - Validate .task file structure against conventions
  - Check required fields (Status, Created, Owner)
  - Verify delegation prompt format
  - Check progress log exists
  - Validate architecture decision format

- `ArchiveTaskCommand.cs` - Archive completed task (move to archive/ with date suffix)
  - Usage: `xeyth-planning archive-task <task-name> [--date YYYY-MM-DD]`
  - Validates task is completed
  - Moves to appropriate archive/ directory
  - Updates related inventories

**Packaging & Distribution**:
- No changes needed (.csproj already configured with PackAsTool=true, ToolCommandName=xeyth-planning)
- Update version in .csproj when ready for release
- Add release notes documenting new context file commands
- Build and test cross-platform (Windows, macOS, Linux) via CI/CD

---

## Progress Log

- 2024-12-24: Task created by Orchestrator - user requested dotnet CLI utilities for context file management
- 2024-12-24: Planning complete (Planner) - Architecture decisions finalized, 6-phase implementation plan created
- 2025-12-26: Planning reviewed and finalized (Planner - Strategic Agent):
  - ✅ Analyzed existing repository structure - `Automation.Planning` already exists as CLI tool for proposal management
  - ✅ Resolved architectural conflict - Updated AD-1 to extend existing `xeyth-planning` tool instead of creating new projects
  - ✅ Updated AD-2 Technology Stack to align with existing patterns (Spectre.Console, custom dispatcher)
  - ✅ Updated AD-3 Project Structure to reflect extending existing codebase
  - ✅ Updated AD-4 Output Format to match existing proposal command pattern (tables + optional JSON)
  - ✅ Updated AD-5 CLI Packaging to extend existing tool
  - ✅ Refined all 6 implementation phases with concrete, actionable steps
  - ✅ Validated plan against existing codebase patterns (ProposalDiscoveryService, ListProposalsCommand, etc.)
  - ✅ Plan ready for delegation to Implementation Agent

## Planner Sign-Off

**Status**: ✅ Planning Complete - Ready for Implementation  
**Date**: 2025-12-26  
**Agent**: Strategic Agent (Claude Sonnet 4.5) - Planner Role

**Summary**: 
Architecture decisions finalized to extend existing `xeyth-planning` CLI tool with context file management commands. Plan leverages existing infrastructure (Spectre.Console, command dispatcher, Automation.Cli.Common) and follows proven patterns from proposal management commands. 6-phase implementation plan provides concrete, actionable steps for Implementation Agent.

**Key Decisions**:
- Extend existing `Automation.Planning` project (not create new projects)
- Add Models (ContextTask, ContextPlan, ContextReport, Convention)
- Add Services (ContextFileParser, ContextFileDiscoveryService, specialized parsers)
- Add Commands (ListTasksCommand, ListPlansCommand, GetTaskMetadataCommand, etc.)
- Follow existing patterns (PlanningCommandBase, StatusSpinner, PlanningReporter)
- Support table output (default) + JSON output (--json flag for automation)

**Implementation Readiness**: ✅ All phases detailed with specific classes, file locations, and patterns to follow.

---

## DELEGATION TO IMPLEMENTATION AGENT

````markdown
**Task**: [Automation/Automation/ContextFileTooling.task](Automation/Automation/ContextFileTooling.task)  
**Role**: Implementer (see [Ai/Framework/Implementation.prompt.md](../../Ai/Framework/Implementation.prompt.md))  
**Target Audience**: Implementation Agent (GPT-5.1-Codex-Max)

Implement context file management commands in existing `xeyth-planning` CLI tool. Extend `Automation.Planning` with Models, Services, and Commands for .task, .plan, .report, and .convention files following established patterns.
````
